slide

Two channels analog reading with Arduino DUE at about 333 kHz using the ADC in free-running mode.
The ADC readings are recorded 2 ms before and 8 ms after an auto-trigger is activated.

Data are saved using a circular buffer, than contains 3332 samples (captured in 10 ms, sampling every 3 us)
After the trigger, 8 ms are recorded and then all the buffer (containing also 2 ms captured before the trigger)
is sent to python over the serial port.
Code:
# define BUFFER_SIZE 3332 // number of samples captured in 10 ms, sampling every 3 us
# define POST_TRIGGER_SAMPLES_NUM 2667 // number of samples captured in 8 ms




slide

The circular buffer and the samples are defined through appropriate data types:

Code: (17 rows)

// struct representing one sample (containing values of I, Q and time)
typedef struct {
  int I, Q; // 4 bytes each
  unsigned int t; // 4 bytes
} Sample; // 12 bytes

// FIFO circular buffer for Sample objects: 
// see https://dl.acm.org/doi/pdf/10.5555/1074100.1074180
typedef struct {
  Sample *buffer;
  int end;
} CircBuffer;

// method to set up the circular buffer
void circ_buffer_setup(CircBuffer *c, Sample *b) {
  c->end = 0;
  c->buffer = b; // inizializes the buffer to an array
}



slide

In the Arduino setup method we allocate memory for the buffer,
using a further element to send to python the
amount of time needed to write the buffer over the serial port
Code: (16 rows)

void setup() {

  circ_buffer = (CircBuffer*) malloc(sizeof(CircBuffer));

  /* to increase serial communication speed, data are sent to python all in one time as an buffer
   * that shares the same memory with the circular buffer (to avoid having to copy it when writing to serial)
   */
  buffer = (Sample*) malloc(sizeof(Sample)*(BUFFER_SIZE + 1));
  circ_buffer_setup(circ_buffer, buffer);

  /* initializes the last element of the buffer, that will be used to send to python the 
   *  amount of time (in us) needed to send a bunch of data (see send function)
   */
  buffer[BUFFER_SIZE] = {0, 0, 0};

  ...
}


slide

To increase sampling rate we manually set the registers of the microcontroller for faster analog reading
(in the Arduino Setup method)

See:
Arduino due processor datasheet:
https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-11057-32-bit-Cortex-M3-Microcontroller-SAM3X-SAM3A_Datasheet.pdf
Arduino due unofficial pinout: 
http://www.robgray.com/temp/Due-pinout.pdf */

Code: (20 rows)

void setup() {
  ...

  // sets free running mode (7th bit) and fast wake up (6th bit) 
  // see page 1333 of the datasheet
  ADC->ADC_MR |= 1 << 7 | 1 << 6;

  /* Setting the ADC to read the pins with I and Q signal.
   * see the pinout for the mapping between Arduino pins and ADC channels
   * ch7: A0, ..., ch0: A7 - ch10: A8, ..., ch13: A11
   */
  I_CHANNEL_NUM = 7; //A0
  Q_CHANNEL_NUM = 13; //A11

  // see page 1338 of the datasheet
  ADC_CHANNELS = (1 << I_CHANNEL_NUM) | (1 << Q_CHANNEL_NUM);
  
  ADC->ADC_CHER = ADC_CHANNELS; // enables channels
  ADC->ADC_CR |= 1 << 1; // begins ADC conversion (1st bit on)

  ...
}


slide

We need two method for data handling:
Code: (23 rows)

// Method that acquires data, puts them in the buffer as a Sample and returns the pointer to it
Sample * acquire_data() {
  // after declaring p, assigns to it the pointer to the Sample that will be filled
  Sample *p = &(circ_buffer->buffer[circ_buffer->end]);
  // puts ahead the buffer index
  circ_buffer->end = (circ_buffer->end + 1) % BUFFER_SIZE;

  // waits until ADC conversion is completed for both channels
  while((ADC->ADC_ISR & ADC_CHANNELS)!=ADC_CHANNELS);
  p->I = ADC->ADC_CDR[I_CHANNEL_NUM];  // read value of I
  p->Q = ADC->ADC_CDR[Q_CHANNEL_NUM];  // read value of Q
  p->t = (unsigned int)(micros() - start_micros);

  return p;
}

// Method to send one bunch of data to python
void send_data() {
  start_sending_micros = micros();
  // in order to reduce dead time, data are sent to python all in one time as an array of bytes
  SerialUSB.write((byte*)buffer, sizeof(Sample)*(BUFFER_SIZE + 1));
  // saves the time needed by arduino to send data
  buffer[BUFFER_SIZE].Q = micros() - start_sending_micros;
}




slide
The trigger is defined such that (no idea - still in progress)
Code:

// trigger method -----------------------------------------------------------------------
int trigger(Sample *s) {
    if (s->I > 20){ // just a reasonable number for now
      return 1;
    }
    else return 0;
}


slide:

The loop function is designed such that Arduino only reads when Python is
ready to save data and exactly for the amount of time needed.
This purpose is achieved using an handshake.

Code: (16 rows)

void loop() {
  // polls whether anything is ready on the read buffer
  // nothing happens until python writes the acquisition time (in s) to the serial
  if (SerialUSB.available() > 0) {
    // handshake - start ----------------------------
    
    //waiting a little time for arduino to be ready to receive data
    delay(100); // ms
    // reads from python the acquisition time in seconds
    acquisition_time_millis = SerialUSB.readString().toInt()*1000;
    // after receiving the value, sends back it in milliseconds to complete handshake
    SerialUSB.println(acquisition_time_millis);
    //waiting a little time for python to be ready to receive data
    delay(100); // ms
    
    ...
}



slide:

The acquisition is performed with a simple while loop, however, when the trigger gets activated,
exactly POST_TRIGGER_SAMPLES_NUM samples (8 ms) of data are recorded with a for loop.
At the end of the for loop, the buffer (containing 10 ms of data) is sent over the serial port.
Code: (24 rows)

void loop() {
    ...
    
    end_millis = millis() + acquisition_time_millis;

    start_micros = micros();
    
    // starting acquisition (for an amount of time set by the acquisition_time variable)
    while (millis() < end_millis) {
      /* reads I, Q and time (in us),
       * saves them in the circular buffer as a Sample and returns the pointer to it
       */
      s = acquire_data();
      
      if (trigger(s)) {
          for(i=0; i<POST_TRIGGER_SAMPLES_NUM; i++) {
            acquire_data();
          }
          send_data();
      }
    ...
      
}


slide 
Data are read 

import serial
import struct
import time
import os
from datetime import datetime

data_folder = "../../../wave_forms"
recording_time = 10

def _handshake(serialinst):

        # writes to Arduino the recording_time (minus 1 s, to be sure python reads all the data) in s
        nbytes = serialinst.write(str(recording_time - 1).encode())

        # reads back the recording_time in ms
        byte_back = serialinst.readline()
        print(f"Recording time: {byte_back.decode()}")

# enables communication with Arduino
ser = serial.Serial(
            port='/dev/ttyACM0',
            baudrate=115200,
            parity=serial.PARITY_NONE,
            stopbits=serial.STOPBITS_ONE,
            bytesize=serial.EIGHTBITS,
            timeout=recording_time,
)

# performs handshake
_handshake(ser)

# starts data acquisition
now = datetime.now() # current date and time of acquisition starting (precision of a second)
date_time = now.strftime("%m-%d-%Y, %H.%M.%S")

acquisition_path = os.path.join(data_folder, date_time)
os.makedirs(acquisition_path)

dt_f = open(os.path.join(acquisition_path, "dead_time.txt"), "w")
dt_f.write("#dead_time(ms)\n")

end_time = time.time() + recording_time
i = 0
while time.time() < end_time:
    # Reads data of 1 triggered event, containing :
    # 3333 samples in the form (I, Q, t)
    # 1 sample containing the time needed by arduino to send data to serial during the previous communication

    raw_data = ser.read(size=39996)   # 12 * (BUFFER_SIZE + 1)

    if len(raw_data) < 12: # on the last acquisition it can happen that nothing is read
      continue

    data_iter = struct.iter_unpack('iiI', raw_data[:-12])

    data_f = open(os.path.join(acquisition_path, f"signal{i}.dat"), "w")

    for it in data_iter:
        data_f.write("{} {} {}\n".format(*it))

    dt = struct.unpack('iiI', raw_data[-12:])
    dt_f.write(f"{dt[1]}\n")

    data_f.close()

    i += 1

dt_f.close()
